
<!DOCTYPE html>
<html lang="en">

    {{- partial "head.html" . -}}

    <body>
        
        <canvas id="julia-background"></canvas>

    <style>
    #julia-background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1; /* Hinter dem Inhalt */
        opacity: 0.05; /* "Ganz leicht erkennbar" - hier anpassen (0.05 = 5%) */
        pointer-events: none; /* Klicks gehen durch den Hintergrund durch */
    }
    </style>

    <script>
    (function() {
        const canvas = document.getElementById('julia-background');
        const ctx = canvas.getContext('2d');
        
        // Zufälliger Parameter c für die Formel z^2 + c
        // Wir wählen Werte im Bereich ca. -1.0 bis 1.0 für interessante Fraktale
        const cr = (Math.random() * 2) - 1;
        const ci = (Math.random() * 2) - 1;

        function draw() {
            // Wir rendern mit niedrigerer Auflösung (1/4) und lassen den Browser skalieren.
            // Das ist schneller und sorgt für einen leicht "weichen" Look, der gut als Hintergrund passt.
            const scale = 4; 
            const w = Math.ceil(window.innerWidth / scale);
            const h = Math.ceil(window.innerHeight / scale);
            
            canvas.width = w;
            canvas.height = h;

            const imgData = ctx.createImageData(w, h);
            const data = imgData.data;
            const maxIter = 60; // Maximale Iterationen (Detailgrad)

            for (let x = 0; x < w; x++) {
                for (let y = 0; y < h; y++) {
                    // Pixel auf die komplexe Ebene abbilden (ca. Bereich -1.5 bis 1.5)
                    // Aspektverhältnis beibehalten
                    let zr = 3 * (x - w / 2) / Math.min(w, h);
                    let zi = 3 * (y - h / 2) / Math.min(w, h);
                    
                    let iter = 0;
                    while (zr*zr + zi*zi < 4 && iter < maxIter) {
                        let temp = zr*zr - zi*zi + cr;
                        zi = 2*zr*zi + ci;
                        zr = temp;
                        iter++;
                    }

                    const offset = (y * w + x) * 4;
                    
                    // Schwarz-Weiß-Logik:
                    // Wenn der Punkt nicht entkommen ist (iter == maxIter) -> Schwarz (0)
                    // Wenn er entkommen ist -> Weiß (255)
                    // Durch die CSS-Opacity von 0.05 wirkt dies wie ein feines Wasserzeichen.
                    const color = iter === maxIter ? 0 : 255;
                    
                    data[offset] = color;     // R
                    data[offset + 1] = color; // G
                    data[offset + 2] = color; // B
                    data[offset + 3] = 255;   // Alpha (Sichtbarkeit wird über CSS gesteuert)
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }

        // Neu zeichnen, wenn das Fenster in der Größe verändert wird
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(draw, 100);
        });

        draw();
    })();
    </script>

        <div class="outer">
            <div class="middle">
                <div class="inner">
                    
                    {{- partial "header.html" . -}}
                    {{- partial "navigation.html" . -}}
                    
                    <main>
                        {{ block "main" . }} {{ end }}
                    </main>

                    {{- partial "footer.html" . -}}

                </div>
            </div>
        </div>

        {{- partial "math.html" . -}}

    </body>
</html>
